// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
	"time"
)

// AddClaimToScope defines model for AddClaimToScope.
type AddClaimToScope struct {

	// Claim id to add
	ClaimId int `json:"claim_id"`
}

// ApiError defines model for ApiError.
type ApiError struct {

	// Error code
	ErrorCode string `json:"error_code"`

	// Detail description
	Message string `json:"message"`
}

// ChangePasswordRequest defines model for ChangePasswordRequest.
type ChangePasswordRequest struct {

	// The new password to set.
	NewPassword string `json:"new_password"`

	// The old or existing password
	OldPassword string `json:"old_password"`
}

// Claim defines model for Claim.
type Claim struct {

	// A short dercription about the claim.
	Description *string `json:"description,omitempty"`

	// Internal identifier of the claim
	Id int `json:"id"`

	// A alphanumeric name, to represent claim name in OAuth2 claim.
	Name string `json:"name"`
}

// ClaimPage defines model for ClaimPage.
type ClaimPage struct {
	// Embedded fields due to inline allOf schema

	// an array of claims
	Claims []Claim `json:"claims"`
	// Embedded struct due to allOf(#/components/schemas/Page)
	Page
}

// Page defines model for Page.
type Page struct {

	// Page number of the response chunk
	PageNumber int `json:"page_number"`

	// Total available pages
	PageTotal int `json:"page_total"`
}

// RegenerateCredentials defines model for RegenerateCredentials.
type RegenerateCredentials struct {

	// Wheather to regenerate the client id too
	RefreshId *bool `json:"refresh_id,omitempty"`
}

// Scope defines model for Scope.
type Scope struct {

	// A short dercription about the scope.
	Description *string `json:"description,omitempty"`

	// Internal identifier of the scope
	Id int `json:"id"`

	// Scope name. alphanumeric characters only.
	Name string `json:"name"`
}

// ScopePage defines model for ScopePage.
type ScopePage struct {
	// Embedded fields due to inline allOf schema

	// An array of scopes as returned in search result or so.
	Scopes []Scope `json:"scopes"`
	// Embedded struct due to allOf(#/components/schemas/Page)
	Page
}

// Secret defines model for Secret.
type Secret struct {

	// Suitable algorithm for the key. allowed values are all supported `JWS` and `JWK` algorithms.
	Algorithm string `json:"algorithm"`

	// Date when the secret expires
	ExpiresAt time.Time `json:"expires_at"`

	// Date when the key was issued
	IssuedAt time.Time `json:"issued_at"`

	// usage of the key
	KeyUsage string `json:"key_usage"`
}

// SecretChannel defines model for SecretChannel.
type SecretChannel struct {

	// Suitable algorithm for the key. allowed values are all supported `JWS` and `JWK` algorithms.
	Algorithm string `json:"algorithm"`

	// Identifier of the `SecretChannel`.
	Id int `json:"id"`

	// usage of the key
	KeyUsage string `json:"key_usage"`

	// A friendly name for the key channel
	Name string `json:"name"`

	// A list of secrets associates with channel
	Secrets []Secret `json:"secrets"`

	// How mant days the key will be valid, when generated or renewed
	ValidityDay int `json:"validity_day"`
}

// SecretChannelPage defines model for SecretChannelPage.
type SecretChannelPage struct {
	// Embedded fields due to inline allOf schema

	// An array of `SecretChannelSummary` objects
	Channels []SecretChannelSummary `json:"channels"`
	// Embedded struct due to allOf(#/components/schemas/Page)
	Page
}

// SecretChannelSummary defines model for SecretChannelSummary.
type SecretChannelSummary struct {

	// Suitable algorithm for the key. allowed values are all supported `JWS` and `JWK` algorithms.
	Algorithm string `json:"algorithm"`

	// Identifier of the `SecretChannel`.
	Id int `json:"id"`

	// usage of the key
	KeyUsage string `json:"key_usage"`

	// A friendly name for the key channel
	Name string `json:"name"`
}

// ServiceProvider defines model for ServiceProvider.
type ServiceProvider struct {
	// Embedded struct due to allOf(#/components/schemas/ServiceProviderInfo)
	ServiceProviderInfo
	// Embedded struct due to allOf(#/components/schemas/ServiceProviderConfig)
	ServiceProviderConfig
	// Embedded struct due to allOf(#/components/schemas/ServiceProviderSummary)
	ServiceProviderSummary
}

// ServiceProviderConfig defines model for ServiceProviderConfig.
type ServiceProviderConfig struct {

	// Default requested Authentication Context Class Reference values. Array of strings that specifies the default acr values that the OP is being requested to use for processing requests from this Client, with the values appearing in order of preference. The Authentication Context Class satisfied by the authentication performed is returned as the acr Claim Value in the issued ID Token. The acr Claim is requested as a Voluntary Claim by this parameter. The acr_values_supported discovery element contains a list of the supported acr values supported by this server. Values specified in the acr_values request parameter or an individual acr Claim request override these default values.
	DefaultAcrValues *[]string `json:"default_acr_values,omitempty"`

	// Default Maximum Authentication Age. Specifies that the End-User MUST be actively authenticated if the End-User was authenticated longer ago than the specified number of seconds. The max_age request parameter overrides this default value. If omitted, no default Maximum Authentication Age is specified.
	DefaultMaxAge *int `json:"default_max_age,omitempty"`

	// JSON array containing a list of the OAuth 2.0 Grant Types that the Client is declaring that it will restrict itself to using. The Grant Type values used by
	//
	// OpenID Connect are:
	// 1. authorization_code: The Authorization Code Grant Type described in OAuth 2.0 Section 4.1.
	// 1. implicit: The Implicit Grant Type described in OAuth 2.0 Section 4.2.
	// 1. refresh_token: The Refresh Token Grant Type described in OAuth 2.0 Section 6.
	//
	// The following table lists the correspondence between response_type values that the Client will use and grant_type values that MUST be included in the registered grant_types list:
	//
	// 1. code: authorization_code
	// 1. id_token: implicit
	// 1. token id_token: implicit
	// 1. code id_token: authorization_code, implicit
	// 1. code token: authorization_code, implicit
	// 1. code token id_token: authorization_code, implicit
	//
	// If omitted, the default is that the Client will use only the authorization_code Grant Type.
	GrantTypes []string `json:"grant_types"`

	// JWE alg algorithm [JWA] REQUIRED for encrypting the ID Token issued to this Client. If this is requested, the response will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The default, if omitted, is that no encryption is performed.
	IdTokenEncryptedResponseAlg *string `json:"id_token_encrypted_response_alg,omitempty"`

	// JWE enc algorithm [JWA] REQUIRED for encrypting the ID Token issued to this Client. If id_token_encrypted_response_alg is specified, the default for this value is A128CBC-HS256. When id_token_encrypted_response_enc is included, id_token_encrypted_response_alg MUST also be provided.
	IdTokenEncryptedResponseEnc *string `json:"id_token_encrypted_response_enc,omitempty"`

	// JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.
	IdTokenSignedResponseAlg *string `json:"id_token_signed_response_alg,omitempty"`

	// Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together.
	Jwks *string `json:"jwks,omitempty"`

	// URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.
	JwksUri *string `json:"jwks_uri,omitempty"`

	// Array of Redirection URI values used by the Client. One of these registered Redirection URI values MUST exactly match the redirect_uri parameter value used in each Authorization Request, with the matching performed as described in Section 6.2.1 of [RFC3986] (Simple String Comparison).
	RedirectUris []string `json:"redirect_uris"`

	//  JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting Request Objects sent to the OP. This parameter SHOULD be included when symmetric encryption will be used, since this signals to the OP that a client_secret value needs to be returned from which the symmetric key will be derived, that might not otherwise be returned. The RP MAY still use other supported encryption algorithms or send unencrypted Request Objects, even when this parameter is present. If both signing and encryption are requested, the Request Object will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The default, if omitted, is that the RP is not declaring whether it might encrypt any Request Objects.
	RequestObjectEncryptionAlg *string `json:"request_object_encryption_alg,omitempty"`

	// JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request Objects sent to the OP. If request_object_encryption_alg is specified, the default for this value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg MUST also be provided.
	RequestObjectEncryptionEnc *string `json:"request_object_encryption_enc,omitempty"`

	// JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm. Request Objects are described in Section 6.1 of OpenID Connect Core 1.0 [OpenID.Core]. This algorithm MUST be used both when the Request Object is passed by value (using the request parameter) and when it is passed by reference (using the request_uri parameter). Servers SHOULD support RS256. The value none MAY be used. The default, if omitted, is that any algorithm supported by the OP and the RP MAY be used.
	RequestObjectSigningAlg *string `json:"request_object_signing_alg,omitempty"`

	// Array of request_uri values that are pre-registered by the RP for use at the OP. Servers MAY cache the contents of the files referenced by these URIs and not retrieve them at the time they are used in a request. OPs can require that request_uri values used be pre-registered with the require_request_uri_registration discovery parameter.
	// If the contents of the request file could ever change, these URI values SHOULD include the base64url encoded SHA-256 hash value of the file contents referenced by the URI as the value of the URI fragment. If the fragment value used for a URI changes, that signals the server that its cached value for that URI with the old fragment value is no longer valid.
	RequestUris *[]string `json:"request_uris,omitempty"`

	// Boolean value specifying whether the auth_time Claim in the ID Token is REQUIRED. It is REQUIRED when the value is true. (If this is false, the auth_time Claim can still be dynamically requested as an individual Claim for the ID Token using the claims request parameter described in Section 5.5.1 of OpenID Connect Core 1.0 [OpenID.Core].) If omitted, the default value is false.
	RequireAuthTime *bool `json:"require_auth_time,omitempty"`

	// Approved oauth scopes for the service providers
	Scope []string `json:"scope"`

	// Requested Client Authentication method for the Token Endpoint. The options are client_secret_post, client_secret_basic, client_secret_jwt, private_key_jwt, and none, as described in Section 9 of OpenID Connect Core 1.0 [OpenID.Core]. Other authentication methods MAY be defined by extensions. If omitted, the default is client_secret_basic -- the HTTP Basic Authentication Scheme specified in Section 2.3.1 of OAuth 2.0 [RFC6749].
	TokenEndpointAuthMethod *string `json:"token_endpoint_auth_method,omitempty"`

	// JWS [JWS] alg algorithm [JWA] that MUST be used for signing the JWT [JWT] used to authenticate the Client at the Token Endpoint for the private_key_jwt and client_secret_jwt authentication methods. All Token Requests using these authentication methods from this Client MUST be rejected, if the JWT is not signed with this algorithm. Servers SHOULD support RS256. The value none MUST NOT be used. The default, if omitted, is that any algorithm supported by the OP and the RP MAY be used.
	TokenEndpointAuthSigningAlg *string `json:"token_endpoint_auth_signing_alg,omitempty"`

	// JWE [JWE] alg algorithm [JWA] REQUIRED for encrypting UserInfo Responses. If both signing and encryption are requested, the response will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The default, if omitted, is that no encryption is performed.
	UserinfoEncryptedResponseAlg *string `json:"userinfo_encrypted_response_alg,omitempty"`

	// JWE enc algorithm [JWA] REQUIRED for encrypting UserInfo Responses. If userinfo_encrypted_response_alg is specified, the default for this value is A128CBC-HS256. When userinfo_encrypted_response_enc is included, userinfo_encrypted_response_alg MUST also be provided.
	UserinfoEncryptedResponseEnc *string `json:"userinfo_encrypted_response_enc,omitempty"`

	// JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.
	UserinfoSignedResponseAlg *string `json:"userinfo_signed_response_alg,omitempty"`
}

// ServiceProviderCredentials defines model for ServiceProviderCredentials.
type ServiceProviderCredentials struct {

	// Client identifier
	ClientId string `json:"client_id"`

	// Client secret
	ClientSecret string `json:"client_secret"`
}

// ServiceProviderInfo defines model for ServiceProviderInfo.
type ServiceProviderInfo struct {

	// Kind of the application. The default, if omitted, is web. The defined values are native or web. Web Clients using the OAuth Implicit Grant Type MUST only register URLs using the https scheme as redirect_uris; they MUST NOT use localhost as the hostname. Native Clients MUST only register redirect_uris using custom URI schemes or URLs using the http: scheme with localhost as the hostname. Authorization Servers MAY place additional constraints on Native Clients. Authorization Servers MAY reject Redirection URI values using the http scheme, other than the localhost case for Native Clients. The Authorization Server MUST verify that all the registered redirect_uris conform to these constraints. This prevents sharing a Client ID across different types of Clients.
	ApplicationType string `json:"application_type"`

	// URL of the home page of the Client. The value of this field MUST point to a valid Web page. If present, the server SHOULD display this URL to the End-User in a followable fashion. If desired, representation of this Claim in different languages and scripts is represented as described in Section 2.1.
	ClientUri *string `json:"client_uri,omitempty"`

	// Array of e-mail addresses of people responsible for this Client. This might be used by some providers to enable a Web user interface to modify the Client information.
	Contacts *[]string `json:"contacts,omitempty"`

	// URI using the https scheme that a third party can use to initiate a login by the RP, as specified in Section 4 of OpenID Connect Core 1.0 [OpenID.Core]. The URI MUST accept requests via both GET and POST. The Client MUST understand the login_hint and iss parameters and SHOULD support the target_link_uri parameter.
	InitiateLoginUri *string `json:"initiate_login_uri,omitempty"`

	// URL that references a logo for the Client application. If present, the server SHOULD display this image to the End-User during approval. The value of this field MUST point to a valid image file. If desired, representation of this Claim in different languages and scripts is represented as described in Section 2.1.
	LogoUri *string `json:"logo_uri,omitempty"`

	// URL that the Relying Party Client provides to the End-User to read about the how the profile data will be used. The value of this field MUST point to a valid web page. The OpenID Provider SHOULD display this URL to the End-User if it is given. If desired, representation of this Claim in different languages and scripts is represented as described in Section 2.1.
	PolicyUri *string `json:"policy_uri,omitempty"`

	// URL that the Relying Party Client provides to the End-User to read about the Relying Party's terms of service. The value of this field MUST point to a valid web page. The OpenID Provider SHOULD display this URL to the End-User if it is given. If desired, representation of this Claim in different languages and scripts is represented as described in Section 2.1.
	TosUri *string `json:"tos_uri,omitempty"`
}

// ServiceProviderSummary defines model for ServiceProviderSummary.
type ServiceProviderSummary struct {

	// A description of the service provider
	Description *string `json:"description,omitempty"`

	// Identifier of the provider.
	Id int `json:"id"`

	// Service provider name
	Name string `json:"name"`

	// Wheather the `ServiceProvider` is a public SP, which does not require authentication.
	Public bool `json:"public"`
}

// ServiceProviderSummaryPage defines model for ServiceProviderSummaryPage.
type ServiceProviderSummaryPage struct {
	// Embedded fields due to inline allOf schema

	// An array of service provider summary in one page.
	ServiceProviders []ServiceProviderSummary `json:"service_providers"`
	// Embedded struct due to allOf(#/components/schemas/Page)
	Page
}

// StatusUpdate defines model for StatusUpdate.
type StatusUpdate struct {

	// New status to change to.
	Active bool `json:"active"`
}

// User defines model for User.
type User struct {
	// Embedded struct due to allOf(#/components/schemas/UserName)
	UserName
	// Embedded struct due to allOf(#/components/schemas/UserProfile)
	UserProfile
	// Embedded struct due to allOf(#/components/schemas/UserContact)
	UserContact
	// Embedded struct due to allOf(#/components/schemas/UserSummary)
	UserSummary
}

// UserAddress defines model for UserAddress.
type UserAddress struct {

	// Country name component.
	Country *string `json:"country,omitempty"`

	// Full mailing address, formatted for display or use on a mailing label. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair ("\r\n") or as a single line feed character ("\n").
	Formatted *string `json:"formatted,omitempty"`

	// City or locality component.
	Locality *string `json:"locality,omitempty"`

	// Zip code or postal code component.
	PostalCode *string `json:"postal_code,omitempty"`

	// State, province, prefecture, or region component.
	Region *string `json:"region,omitempty"`

	// Full street address component, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair ("\r\n") or as a single line feed character ("\n").
	StreetAddress *string `json:"street_address,omitempty"`
}

// UserContact defines model for UserContact.
type UserContact struct {

	// End-User's preferred e-mail address. Its value MUST conform to the RFC 5322 [RFC5322] addr-spec syntax. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7.
	Email *string `json:"email,omitempty"`

	// True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. The means by which an e-mail address is verified is context-specific, and dependent upon the trust framework or contractual agreements within which the parties are operating.
	EmailVerified *bool `json:"email_verified,omitempty"`

	// End-User's preferred telephone number. E.164 [E.164] is RECOMMENDED as the format of this Claim, for example, +1 (425) 555-1212 or +56 (2) 687 2400. If the phone number contains an extension, it is RECOMMENDED that the extension be represented using the RFC 3966 [RFC3966] extension syntax, for example, +1 (604) 555-1234;ext=5678.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// User at the time the verification was performed. The means by which a phone number is verified is context-specific, and dependent upon the trust framework or contractual agreements within which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be represented in RFC 3966 format.
	PhoneNumberVerified *bool `json:"phone_number_verified,omitempty"`
}

// UserName defines model for UserName.
type UserName struct {

	// Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
	FamilyName *string `json:"family_name,omitempty"`

	// Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
	GivenName *string `json:"given_name,omitempty"`

	// Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
	MiddleName *string `json:"middle_name,omitempty"`

	// End-User's full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User's locale and preferences.
	Name *string `json:"name,omitempty"`

	// Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
	Nickname *string `json:"nickname,omitempty"`

	// Shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The RP MUST NOT rely upon this value being unique.
	PreferredUsername *string `json:"preferred_username,omitempty"`
}

// UserProfile defines model for UserProfile.
type UserProfile struct {

	// End-User's preferred postal address. The value of the address member is a JSON [RFC4627] structure containing some or all of the members defined in Section 5.1.1.
	Address *UserAddress `json:"address,omitempty"`

	// End-User's birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`

	// End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
	Gender *string `json:"gender,omitempty"`

	// End-User's locale, represented as a BCP47 [RFC5646] language tag. This is typically an ISO 639-1 Alpha-2 [ISO639‑1] language code in lowercase and an ISO 3166-1 Alpha-2 [ISO3166‑1] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, some implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept this locale syntax as well.
	Locale *string `json:"locale,omitempty"`

	// URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
	Picture *string `json:"picture,omitempty"`

	// URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User.
	Profile *string `json:"profile,omitempty"`

	// URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
	Website *string `json:"website,omitempty"`

	// String from zoneinfo [zoneinfo] time zone database representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles.
	Zoneinfo *string `json:"zoneinfo,omitempty"`
}

// UserRecoverPassword defines model for UserRecoverPassword.
type UserRecoverPassword struct {

	// Email id of the user to confirm with user store
	Email string `json:"email"`

	// Username of the user
	Username string `json:"username"`
}

// UserResetPassword defines model for UserResetPassword.
type UserResetPassword struct {

	// One time password received through initiation process
	Otp string `json:"otp"`

	// New password to set to user
	Password string `json:"password"`

	// Username of the user
	Username string `json:"username"`
}

// UserSummary defines model for UserSummary.
type UserSummary struct {

	// User is active or inactive
	Active bool `json:"active"`

	// User is blocked by invalid attempt
	Blocked bool `json:"blocked"`

	// Email address
	Email string `json:"email"`

	// Internal identifier of the user
	Id int `json:"id"`

	// Login username
	Username string `json:"username"`
}

// UserSummaryPage defines model for UserSummaryPage.
type UserSummaryPage struct {
	// Embedded fields due to inline allOf schema

	// A collection of users
	Users []UserSummary `json:"users"`
	// Embedded struct due to allOf(#/components/schemas/Page)
	Page
}

// UnAuthorized defines model for UnAuthorized.
type UnAuthorized ApiError

// GetClaimsParams defines parameters for GetClaims.
type GetClaimsParams struct {

	// Number of items in each page.
	// Default value is 10.
	PageSize *int `json:"page_size,omitempty"`

	// Page number to return in response.
	// Starts with 1 and default value is 1 too.
	PageNumber *int `json:"page_number,omitempty"`
}

// CreateClaimJSONBody defines parameters for CreateClaim.
type CreateClaimJSONBody Claim

// FindClaimByNameParams defines parameters for FindClaimByName.
type FindClaimByNameParams struct {

	// name of the claim
	Name string `json:"name"`
}

// UpdateClaimJSONBody defines parameters for UpdateClaim.
type UpdateClaimJSONBody Claim

// GetScopesParams defines parameters for GetScopes.
type GetScopesParams struct {

	// Number of items in each page.
	// Default value is 10.
	PageSize *int `json:"page_size,omitempty"`

	// Page number to return in response.
	// Starts with 1 and default value is 1 too.
	PageNumber *int `json:"page_number,omitempty"`
}

// CreateScopeJSONBody defines parameters for CreateScope.
type CreateScopeJSONBody Scope

// FindScopeByNameParams defines parameters for FindScopeByName.
type FindScopeByNameParams struct {

	// scope name
	Name string `json:"name"`
}

// UpdateScopeJSONBody defines parameters for UpdateScope.
type UpdateScopeJSONBody Scope

// AddClaimToScopeJSONBody defines parameters for AddClaimToScope.
type AddClaimToScopeJSONBody AddClaimToScope

// GetSecretChannelsParams defines parameters for GetSecretChannels.
type GetSecretChannelsParams struct {

	// Number of items in each page.
	// Default value is 10.
	PageSize *int `json:"page_size,omitempty"`

	// Page number to return in response.
	// Starts with 1 and default value is 1 too.
	PageNumber *int `json:"page_number,omitempty"`
}

// CreateSecretChannelJSONBody defines parameters for CreateSecretChannel.
type CreateSecretChannelJSONBody SecretChannel

// FindSecretChannelByAlgouseParams defines parameters for FindSecretChannelByAlgouse.
type FindSecretChannelByAlgouseParams struct {

	// algorithm of the channel
	Algo string `json:"algo"`

	// usage of the secret channel
	Use string `json:"use"`
}

// FindSecretChannelByNameParams defines parameters for FindSecretChannelByName.
type FindSecretChannelByNameParams struct {

	// name of the secret channel
	Name string `json:"name"`
}

// GetServiceProvidersParams defines parameters for GetServiceProviders.
type GetServiceProvidersParams struct {

	// Number of items in each page.
	// Default value is 10.
	PageSize *int `json:"page_size,omitempty"`

	// Page number to return in response.
	// Starts with 1 and default value is 1 too.
	PageNumber *int `json:"page_number,omitempty"`
}

// CreateServiceProviderJSONBody defines parameters for CreateServiceProvider.
type CreateServiceProviderJSONBody ServiceProvider

// FindServiceProviderParams defines parameters for FindServiceProvider.
type FindServiceProviderParams struct {

	// service provider name
	Name *string `json:"name,omitempty"`

	// service provider client id
	ClientId *string `json:"client_id,omitempty"`
}

// PatchServiceProviderJSONBody defines parameters for PatchServiceProvider.
type PatchServiceProviderJSONBody ServiceProvider

// UpdateServiceProviderJSONBody defines parameters for UpdateServiceProvider.
type UpdateServiceProviderJSONBody ServiceProvider

// GenerateCredentialsJSONBody defines parameters for GenerateCredentials.
type GenerateCredentialsJSONBody RegenerateCredentials

// UpdateServiceProviderStatusJSONBody defines parameters for UpdateServiceProviderStatus.
type UpdateServiceProviderStatusJSONBody StatusUpdate

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {

	// Number of items in each page.
	// Default value is 10.
	PageSize *int `json:"page_size,omitempty"`

	// Page number to return in response.
	// Starts with 1 and default value is 1 too.
	PageNumber *int `json:"page_number,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody User

// FindUserParams defines parameters for FindUser.
type FindUserParams struct {

	// Username of the user
	Username *string `json:"username,omitempty"`

	// email of the user
	Email *string `json:"email,omitempty"`
}

// InitiatePasswordRecoveryJSONBody defines parameters for InitiatePasswordRecovery.
type InitiatePasswordRecoveryJSONBody UserRecoverPassword

// ResetUserPasswordJSONBody defines parameters for ResetUserPassword.
type ResetUserPasswordJSONBody UserResetPassword

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody User

// ChangeUserPasswordJSONBody defines parameters for ChangeUserPassword.
type ChangeUserPasswordJSONBody ChangePasswordRequest

// UpdateUserStatusJSONBody defines parameters for UpdateUserStatus.
type UpdateUserStatusJSONBody StatusUpdate

// CreateClaimRequestBody defines body for CreateClaim for application/json ContentType.
type CreateClaimJSONRequestBody CreateClaimJSONBody

// UpdateClaimRequestBody defines body for UpdateClaim for application/json ContentType.
type UpdateClaimJSONRequestBody UpdateClaimJSONBody

// CreateScopeRequestBody defines body for CreateScope for application/json ContentType.
type CreateScopeJSONRequestBody CreateScopeJSONBody

// UpdateScopeRequestBody defines body for UpdateScope for application/json ContentType.
type UpdateScopeJSONRequestBody UpdateScopeJSONBody

// AddClaimToScopeRequestBody defines body for AddClaimToScope for application/json ContentType.
type AddClaimToScopeJSONRequestBody AddClaimToScopeJSONBody

// CreateSecretChannelRequestBody defines body for CreateSecretChannel for application/json ContentType.
type CreateSecretChannelJSONRequestBody CreateSecretChannelJSONBody

// CreateServiceProviderRequestBody defines body for CreateServiceProvider for application/json ContentType.
type CreateServiceProviderJSONRequestBody CreateServiceProviderJSONBody

// PatchServiceProviderRequestBody defines body for PatchServiceProvider for application/json ContentType.
type PatchServiceProviderJSONRequestBody PatchServiceProviderJSONBody

// UpdateServiceProviderRequestBody defines body for UpdateServiceProvider for application/json ContentType.
type UpdateServiceProviderJSONRequestBody UpdateServiceProviderJSONBody

// GenerateCredentialsRequestBody defines body for GenerateCredentials for application/json ContentType.
type GenerateCredentialsJSONRequestBody GenerateCredentialsJSONBody

// UpdateServiceProviderStatusRequestBody defines body for UpdateServiceProviderStatus for application/json ContentType.
type UpdateServiceProviderStatusJSONRequestBody UpdateServiceProviderStatusJSONBody

// CreateUserRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// InitiatePasswordRecoveryRequestBody defines body for InitiatePasswordRecovery for application/json ContentType.
type InitiatePasswordRecoveryJSONRequestBody InitiatePasswordRecoveryJSONBody

// ResetUserPasswordRequestBody defines body for ResetUserPassword for application/json ContentType.
type ResetUserPasswordJSONRequestBody ResetUserPasswordJSONBody

// UpdateUserRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// ChangeUserPasswordRequestBody defines body for ChangeUserPassword for application/json ContentType.
type ChangeUserPasswordJSONRequestBody ChangeUserPasswordJSONBody

// UpdateUserStatusRequestBody defines body for UpdateUserStatus for application/json ContentType.
type UpdateUserStatusJSONRequestBody UpdateUserStatusJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List All claims
	// (GET /v1/api/claims)
	GetClaims(ctx echo.Context, params GetClaimsParams) error
	// Create a Claim
	// (POST /v1/api/claims)
	CreateClaim(ctx echo.Context) error
	// find claim by name
	// (GET /v1/api/claims/find)
	FindClaimByName(ctx echo.Context, params FindClaimByNameParams) error
	// Delete a Claim
	// (DELETE /v1/api/claims/{id})
	DeleteClaim(ctx echo.Context, id int) error
	// Get a Claim
	// (GET /v1/api/claims/{id})
	GetClaim(ctx echo.Context, id int) error
	// Update a Claim
	// (PUT /v1/api/claims/{id})
	UpdateClaim(ctx echo.Context, id int) error
	// List All scopes
	// (GET /v1/api/scopes)
	GetScopes(ctx echo.Context, params GetScopesParams) error
	// Create a Scope
	// (POST /v1/api/scopes)
	CreateScope(ctx echo.Context) error
	// Used to find a scope with name
	// (GET /v1/api/scopes/find)
	FindScopeByName(ctx echo.Context, params FindScopeByNameParams) error
	// Delete a Scope
	// (DELETE /v1/api/scopes/{id})
	DeleteScope(ctx echo.Context, id int) error
	// Get a Scope
	// (GET /v1/api/scopes/{id})
	GetScope(ctx echo.Context, id int) error
	// Update a Scope
	// (PUT /v1/api/scopes/{id})
	UpdateScope(ctx echo.Context, id int) error
	// Add a claim to a scope
	// (POST /v1/api/scopes/{id}/claim)
	AddClaimToScope(ctx echo.Context, id int) error
	// Remove one claim from scope
	// (DELETE /v1/api/scopes/{id}/claim/{claimId})
	RemoveClaimFromScope(ctx echo.Context, id int, claimId int) error
	// List All secretchannels
	// (GET /v1/api/secretchannels)
	GetSecretChannels(ctx echo.Context, params GetSecretChannelsParams) error
	// Create a SecretChannel
	// (POST /v1/api/secretchannels)
	CreateSecretChannel(ctx echo.Context) error
	// Find secret channel by algo and use
	// (GET /v1/api/secretchannels/find/algouse)
	FindSecretChannelByAlgouse(ctx echo.Context, params FindSecretChannelByAlgouseParams) error
	// Fins secret by name
	// (GET /v1/api/secretchannels/find/name)
	FindSecretChannelByName(ctx echo.Context, params FindSecretChannelByNameParams) error
	// Delete a SecretChannel
	// (DELETE /v1/api/secretchannels/{id})
	DeleteSecretChannel(ctx echo.Context, id int) error
	// Get a SecretChannel
	// (GET /v1/api/secretchannels/{id})
	GetSecretChannel(ctx echo.Context, id int) error
	// Renew the secret of the channel
	// (POST /v1/api/secretchannels/{id})
	RenewSecretChannel(ctx echo.Context, id int) error
	// List All serviceproviders
	// (GET /v1/api/serviceproviders)
	GetServiceProviders(ctx echo.Context, params GetServiceProvidersParams) error
	// Create a ServiceProvider
	// (POST /v1/api/serviceproviders)
	CreateServiceProvider(ctx echo.Context) error
	// find sp by client id or name
	// (GET /v1/api/serviceproviders/find)
	FindServiceProvider(ctx echo.Context, params FindServiceProviderParams) error
	// Delete a ServiceProvider
	// (DELETE /v1/api/serviceproviders/{id})
	DeleteServiceProvider(ctx echo.Context, id int) error
	// Get a ServiceProvider
	// (GET /v1/api/serviceproviders/{id})
	GetServiceProvider(ctx echo.Context, id int) error
	// Patch service provider
	// (PATCH /v1/api/serviceproviders/{id})
	PatchServiceProvider(ctx echo.Context, id int) error
	// Update a ServiceProvider
	// (PUT /v1/api/serviceproviders/{id})
	UpdateServiceProvider(ctx echo.Context, id int) error
	// Retrieves the existing credentials
	// (GET /v1/api/serviceproviders/{id}/credentials)
	GetCredentials(ctx echo.Context, id int) error
	// Generate the credentials
	// (POST /v1/api/serviceproviders/{id}/credentials)
	GenerateCredentials(ctx echo.Context, id int) error
	// Activate or Deactivate a service provider
	// (POST /v1/api/serviceproviders/{id}/status)
	UpdateServiceProviderStatus(ctx echo.Context, id int) error
	// List All users
	// (GET /v1/api/users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// Create a User
	// (POST /v1/api/users)
	CreateUser(ctx echo.Context) error
	// find user by username or email id
	// (GET /v1/api/users/find)
	FindUser(ctx echo.Context, params FindUserParams) error
	// Initiate Password Recovery
	// (POST /v1/api/users/recover/password)
	InitiatePasswordRecovery(ctx echo.Context) error
	// Reset password, after recovery
	// (PUT /v1/api/users/recover/password)
	ResetUserPassword(ctx echo.Context) error
	// Delete a User
	// (DELETE /v1/api/users/{id})
	DeleteUser(ctx echo.Context, id int) error
	// Get a User
	// (GET /v1/api/users/{id})
	GetUser(ctx echo.Context, id int) error
	// Update a User
	// (PUT /v1/api/users/{id})
	UpdateUser(ctx echo.Context, id int) error
	// Change Password
	// (POST /v1/api/users/{id}/password)
	ChangeUserPassword(ctx echo.Context, id int) error
	// Update status
	// (POST /v1/api/users/{id}/status)
	UpdateUserStatus(ctx echo.Context, id int) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetClaims converts echo context to params.
func (w *ServerInterfaceWrapper) GetClaims(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClaimsParams
	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// ------------- Optional query parameter "page_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_number", ctx.QueryParams(), &params.PageNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetClaims(ctx, params)
	return err
}

// CreateClaim converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClaim(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateClaim(ctx)
	return err
}

// FindClaimByName converts echo context to params.
func (w *ServerInterfaceWrapper) FindClaimByName(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindClaimByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindClaimByName(ctx, params)
	return err
}

// DeleteClaim converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteClaim(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteClaim(ctx, id)
	return err
}

// GetClaim converts echo context to params.
func (w *ServerInterfaceWrapper) GetClaim(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetClaim(ctx, id)
	return err
}

// UpdateClaim converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateClaim(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateClaim(ctx, id)
	return err
}

// GetScopes converts echo context to params.
func (w *ServerInterfaceWrapper) GetScopes(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScopesParams
	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// ------------- Optional query parameter "page_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_number", ctx.QueryParams(), &params.PageNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScopes(ctx, params)
	return err
}

// CreateScope converts echo context to params.
func (w *ServerInterfaceWrapper) CreateScope(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateScope(ctx)
	return err
}

// FindScopeByName converts echo context to params.
func (w *ServerInterfaceWrapper) FindScopeByName(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindScopeByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindScopeByName(ctx, params)
	return err
}

// DeleteScope converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteScope(ctx, id)
	return err
}

// GetScope converts echo context to params.
func (w *ServerInterfaceWrapper) GetScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScope(ctx, id)
	return err
}

// UpdateScope converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateScope(ctx, id)
	return err
}

// AddClaimToScope converts echo context to params.
func (w *ServerInterfaceWrapper) AddClaimToScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddClaimToScope(ctx, id)
	return err
}

// RemoveClaimFromScope converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveClaimFromScope(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "claimId" -------------
	var claimId int

	err = runtime.BindStyledParameter("simple", false, "claimId", ctx.Param("claimId"), &claimId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter claimId: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveClaimFromScope(ctx, id, claimId)
	return err
}

// GetSecretChannels converts echo context to params.
func (w *ServerInterfaceWrapper) GetSecretChannels(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSecretChannelsParams
	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// ------------- Optional query parameter "page_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_number", ctx.QueryParams(), &params.PageNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSecretChannels(ctx, params)
	return err
}

// CreateSecretChannel converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSecretChannel(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSecretChannel(ctx)
	return err
}

// FindSecretChannelByAlgouse converts echo context to params.
func (w *ServerInterfaceWrapper) FindSecretChannelByAlgouse(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindSecretChannelByAlgouseParams
	// ------------- Required query parameter "algo" -------------

	err = runtime.BindQueryParameter("form", true, true, "algo", ctx.QueryParams(), &params.Algo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter algo: %s", err))
	}

	// ------------- Required query parameter "use" -------------

	err = runtime.BindQueryParameter("form", true, true, "use", ctx.QueryParams(), &params.Use)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter use: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindSecretChannelByAlgouse(ctx, params)
	return err
}

// FindSecretChannelByName converts echo context to params.
func (w *ServerInterfaceWrapper) FindSecretChannelByName(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindSecretChannelByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindSecretChannelByName(ctx, params)
	return err
}

// DeleteSecretChannel converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSecretChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteSecretChannel(ctx, id)
	return err
}

// GetSecretChannel converts echo context to params.
func (w *ServerInterfaceWrapper) GetSecretChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSecretChannel(ctx, id)
	return err
}

// RenewSecretChannel converts echo context to params.
func (w *ServerInterfaceWrapper) RenewSecretChannel(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RenewSecretChannel(ctx, id)
	return err
}

// GetServiceProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetServiceProviders(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServiceProvidersParams
	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// ------------- Optional query parameter "page_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_number", ctx.QueryParams(), &params.PageNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServiceProviders(ctx, params)
	return err
}

// CreateServiceProvider converts echo context to params.
func (w *ServerInterfaceWrapper) CreateServiceProvider(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateServiceProvider(ctx)
	return err
}

// FindServiceProvider converts echo context to params.
func (w *ServerInterfaceWrapper) FindServiceProvider(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindServiceProviderParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindServiceProvider(ctx, params)
	return err
}

// DeleteServiceProvider converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteServiceProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteServiceProvider(ctx, id)
	return err
}

// GetServiceProvider converts echo context to params.
func (w *ServerInterfaceWrapper) GetServiceProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetServiceProvider(ctx, id)
	return err
}

// PatchServiceProvider converts echo context to params.
func (w *ServerInterfaceWrapper) PatchServiceProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchServiceProvider(ctx, id)
	return err
}

// UpdateServiceProvider converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateServiceProvider(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateServiceProvider(ctx, id)
	return err
}

// GetCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetCredentials(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCredentials(ctx, id)
	return err
}

// GenerateCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateCredentials(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GenerateCredentials(ctx, id)
	return err
}

// UpdateServiceProviderStatus converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateServiceProviderStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateServiceProviderStatus(ctx, id)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_size: %s", err))
	}

	// ------------- Optional query parameter "page_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_number", ctx.QueryParams(), &params.PageNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page_number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateUser(ctx)
	return err
}

// FindUser converts echo context to params.
func (w *ServerInterfaceWrapper) FindUser(ctx echo.Context) error {
	var err error

	ctx.Set("OAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindUserParams
	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", ctx.QueryParams(), &params.Email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindUser(ctx, params)
	return err
}

// InitiatePasswordRecovery converts echo context to params.
func (w *ServerInterfaceWrapper) InitiatePasswordRecovery(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InitiatePasswordRecovery(ctx)
	return err
}

// ResetUserPassword converts echo context to params.
func (w *ServerInterfaceWrapper) ResetUserPassword(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ResetUserPassword(ctx)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUser(ctx, id)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUser(ctx, id)
	return err
}

// ChangeUserPassword converts echo context to params.
func (w *ServerInterfaceWrapper) ChangeUserPassword(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ChangeUserPassword(ctx, id)
	return err
}

// UpdateUserStatus converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUserStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("OAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUserStatus(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v1/api/claims", wrapper.GetClaims)
	router.POST("/v1/api/claims", wrapper.CreateClaim)
	router.GET("/v1/api/claims/find", wrapper.FindClaimByName)
	router.DELETE("/v1/api/claims/:id", wrapper.DeleteClaim)
	router.GET("/v1/api/claims/:id", wrapper.GetClaim)
	router.PUT("/v1/api/claims/:id", wrapper.UpdateClaim)
	router.GET("/v1/api/scopes", wrapper.GetScopes)
	router.POST("/v1/api/scopes", wrapper.CreateScope)
	router.GET("/v1/api/scopes/find", wrapper.FindScopeByName)
	router.DELETE("/v1/api/scopes/:id", wrapper.DeleteScope)
	router.GET("/v1/api/scopes/:id", wrapper.GetScope)
	router.PUT("/v1/api/scopes/:id", wrapper.UpdateScope)
	router.POST("/v1/api/scopes/:id/claim", wrapper.AddClaimToScope)
	router.DELETE("/v1/api/scopes/:id/claim/:claimId", wrapper.RemoveClaimFromScope)
	router.GET("/v1/api/secretchannels", wrapper.GetSecretChannels)
	router.POST("/v1/api/secretchannels", wrapper.CreateSecretChannel)
	router.GET("/v1/api/secretchannels/find/algouse", wrapper.FindSecretChannelByAlgouse)
	router.GET("/v1/api/secretchannels/find/name", wrapper.FindSecretChannelByName)
	router.DELETE("/v1/api/secretchannels/:id", wrapper.DeleteSecretChannel)
	router.GET("/v1/api/secretchannels/:id", wrapper.GetSecretChannel)
	router.POST("/v1/api/secretchannels/:id", wrapper.RenewSecretChannel)
	router.GET("/v1/api/serviceproviders", wrapper.GetServiceProviders)
	router.POST("/v1/api/serviceproviders", wrapper.CreateServiceProvider)
	router.GET("/v1/api/serviceproviders/find", wrapper.FindServiceProvider)
	router.DELETE("/v1/api/serviceproviders/:id", wrapper.DeleteServiceProvider)
	router.GET("/v1/api/serviceproviders/:id", wrapper.GetServiceProvider)
	router.PATCH("/v1/api/serviceproviders/:id", wrapper.PatchServiceProvider)
	router.PUT("/v1/api/serviceproviders/:id", wrapper.UpdateServiceProvider)
	router.GET("/v1/api/serviceproviders/:id/credentials", wrapper.GetCredentials)
	router.POST("/v1/api/serviceproviders/:id/credentials", wrapper.GenerateCredentials)
	router.POST("/v1/api/serviceproviders/:id/status", wrapper.UpdateServiceProviderStatus)
	router.GET("/v1/api/users", wrapper.GetUsers)
	router.POST("/v1/api/users", wrapper.CreateUser)
	router.GET("/v1/api/users/find", wrapper.FindUser)
	router.POST("/v1/api/users/recover/password", wrapper.InitiatePasswordRecovery)
	router.PUT("/v1/api/users/recover/password", wrapper.ResetUserPassword)
	router.DELETE("/v1/api/users/:id", wrapper.DeleteUser)
	router.GET("/v1/api/users/:id", wrapper.GetUser)
	router.PUT("/v1/api/users/:id", wrapper.UpdateUser)
	router.POST("/v1/api/users/:id/password", wrapper.ChangeUserPassword)
	router.POST("/v1/api/users/:id/status", wrapper.UpdateUserStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
